package info.mmpa.concoction.scan.dynamic;

import dev.xdark.ssvm.execution.VMException;
import info.mmpa.concoction.input.model.ApplicationModel;
import info.mmpa.concoction.input.model.path.SourcePathElement;
import info.mmpa.concoction.output.Results;
import info.mmpa.concoction.output.ResultsSink;
import info.mmpa.concoction.scan.model.ScanModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import java.util.Collection;
import java.util.List;

/**
 * Advanced dynamic pattern matching based scanning.
 */
public class DynamicScanner {
	private static final Logger logger = LoggerFactory.getLogger(DynamicScanner.class);
	private final EntryPointDiscovery entryPointDiscovery;
	private final CoverageEntryPointSupplier coverageEntryPointSupplier;
	private final Collection<ScanModel> scanModels;

	/**
	 * @param entryPointDiscovery
	 * 		Supplier of initial entry points for known cases.
	 * @param coverageEntryPointSupplier
	 * 		Supplier to fill in additional entry points to maximize scanned code coverage.
	 * @param scanModels
	 * 		List of detection models to scan for.
	 */
	public DynamicScanner(@Nonnull EntryPointDiscovery entryPointDiscovery,
						  @Nonnull CoverageEntryPointSupplier coverageEntryPointSupplier,
						  @Nonnull Collection<ScanModel> scanModels) {
		this.entryPointDiscovery = entryPointDiscovery;
		this.coverageEntryPointSupplier = coverageEntryPointSupplier;
		this.scanModels = scanModels;
	}

	/**
	 * @param model
	 * 		Model to scan.
	 *
	 * @return Detection results found in the model's primary source.
	 *
	 * @throws DynamicScanException
	 * 		When dynamic scanning encountered a problem.
	 */
	@Nonnull
	@SuppressWarnings("UnnecessaryLocalVariable")
	public Results accept(@Nonnull ApplicationModel model) throws DynamicScanException {
		ResultsSink sink = new ResultsSink();
		SsvmContext context = new SsvmContext(model, sink, new SourcePathElement(model.primarySource()), scanModels);

		// Visit initial entry points
		List<EntryPoint> initialEntryPoints = entryPointDiscovery.createEntryPoints(model, context);
		for (EntryPoint entryPoint : initialEntryPoints) {
			handle(entryPoint, ep -> ep.invoke(context));
		}

		// Continually visit remaining entry points (generated by the supplier) until no more are given.
		// The supplier should be defined such that new entry points are provided until enough of the application
		// logic has been visited.
		CoverageEntryPointSupplier supplier = coverageEntryPointSupplier;
		EntryPoint lastEntryPoint = null;
		EntryPoint entryPoint;
		while ((entryPoint = supplier.nextEntryPoint(model, context)) != null) {
			if (entryPoint.equals(lastEntryPoint)) {
				logger.warn("Coverage entry point supplier gave same entry point twice in a row, aborting coverage scanning");
				break;
			}
			handle(entryPoint, ep -> ep.invoke(context));
			lastEntryPoint = entryPoint;
		}

		// Build results from what we found
		return sink.buildResults();
	}

	private void handle(@Nonnull EntryPoint entryPoint, @Nonnull ThrowingHandler handler) throws DynamicScanException {
		try {
			handler.handle(entryPoint);
		} catch (ClassNotFoundException ex) {
			logger.error("The entry point class '{}' was not found in the application model", entryPoint.getClassName(), ex);
			throw new DynamicScanException(ex);
		} catch (VMException ex) {
			logger.error("The dynamic analysis VM saw an uncaught error when handling the entry point class '{}'", entryPoint.getClassName(), ex);
			throw new DynamicScanException(ex);
		} catch (Throwable t) {
			logger.error("Unhandled error when analyzing the entry point class '{}'", entryPoint.getClassName(), t);
			throw new DynamicScanException(t);
		}
	}

	private interface ThrowingHandler {
		void handle(EntryPoint entryPoint) throws Throwable;
	}
}
